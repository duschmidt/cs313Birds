Task List (On existing Google Doc (notes)):        
        1a. Move current branch to new branch, called Prototype, continue work on master
        1b. Google Doc (this) (misc. documentation)
        2. Write Stubs for all but Frame (game logic)
        3. Write GameState, using stubs of other classes
        4. Write EntityGroup
        5. Write Entitiy
        6. Write Stub for Frame
        7. Write Frame
        ...
        Write 3D Frame
        Make movements continuous

NOTE: reflect design choices in this doc!!

Questions:
	How do environment metric cells get updated graphically?
		Should they be treated as sprites or something different?

Frame:
	The purpose of this class is to render the graphic elements of our game

	Attributes:
		GameState gameState

	Methods:

		updateSprites(Group updatedSprites) #draws each sprite in the group and removes the sprite from the group
		drawSprite(Sprite s) #draws some sprite
		drawMetricLayer(numpy.ndArray environmentMetricLayer )

EntityGroup
    Extends Pygame group

    ATTRIBUTES:
        int ID # reference / id into this group's diffusion array       
        GameState gameState
        Group entityGroup #sprite groups for entities
		Group updatedEntities #is a sprite group containing all sprites who were updated

		float diffusionRates #diffusion rates

    METHODS:
        __init__(self, GameState) # keep reference to GameState parent
                                  # diffuse once

        update() # use ID key to get my diffusion array from gameState
                 # updates entities, and then diffuses
                 # pass local neighborhood views into all numpy arrays to each entity

        getUpdatedEntities() #returns a list of all sprites which changed as result of last update                
        add|removeEntity(id)

GameState:
	The purpose of this class is to keep track of the game state.

	Attributes:
        Keys for Bird, Food, etc.
        GameObject{}		
		numpy.ndArray{} diffusionArrays #numpy arrays, parallel to Game Object
        obstacleAry

	Methods:
		updateAllGroups(diffusionIterations) #diffuses environment Metrics using diffusionRates
         				 					 #calls update on all sprite groups
		getAllUpdatedEntities() #returns a list of all sprites which changed as result of last update
        (col, row) positionToDiscrete((x, y) position)
        add|removeEntity(layer, id)
        Entity[] getEntities(col, row)


Entity:
    Extends the Pygame sprite, w/ position info move method, etc.
	This is a base class for our game entities.
    
	Attributes:
		float[] position #list/tuple of 2 or 3 float values indicating position
        int[][] neighborPosition # list of neighbor positions, can change depending on type (food won't change, for example)
		int spriteID #some identifier, like Tkinter rectangle id
        
	Methods:
        __init__(self, EntityGroup) # get GameState / my layer ID from EntityGroup
		update() # uses position / neighborPositions as indices into numpy arrays from GameState to make a decision
                 # check my updated position to see if I'm on food, or bird, or any interactable object
                 # in short: move, interact
